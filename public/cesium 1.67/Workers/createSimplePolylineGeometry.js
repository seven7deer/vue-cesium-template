/**
 * Cesium - https://github.com/CesiumGS/cesium
 *
 * Copyright 2011-2020 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/master/LICENSE.md for full licensing details.
 */
define(["./when-a55a8a4c","./Check-bc1d37d9","./Math-d7cbfcf6","./Cartesian2-6ec3db89","./Transforms-a4d7073e","./RuntimeError-7c184ac0","./WebGLConstants-4c11ee5f","./ComponentDatatype-919a7463","./GeometryAttribute-291ff23b","./GeometryAttributes-1c7ce91d","./IndexDatatype-4351ba4c","./IntersectionTests-3d9e1b94","./Plane-37b84dad","./ArcType-66bc286a","./EllipsoidRhumbLine-4d1a57d2","./EllipsoidGeodesic-365e69f7","./PolylinePipeline-83c8909c","./Color-7baed48c"],function(S,c,I,R,O,e,o,M,U,q,N,r,t,F,a,i,H,W){"use strict";function Y(e,o,r,t,a,i,l){var n,s=H.PolylinePipeline.numberOfPoints(e,o,a),d=r.red,p=r.green,c=r.blue,f=r.alpha,y=t.red,u=t.green,h=t.blue,C=t.alpha;if(W.Color.equals(r,t)){for(n=0;n<s;n++)i[l++]=W.Color.floatToByte(d),i[l++]=W.Color.floatToByte(p),i[l++]=W.Color.floatToByte(c),i[l++]=W.Color.floatToByte(f);return l}var g=(y-d)/s,T=(u-p)/s,v=(h-c)/s,m=(C-f)/s,E=l;for(n=0;n<s;n++)i[E++]=W.Color.floatToByte(d+n*g),i[E++]=W.Color.floatToByte(p+n*T),i[E++]=W.Color.floatToByte(c+n*v),i[E++]=W.Color.floatToByte(f+n*m);return E}function f(e){var o=(e=S.defaultValue(e,S.defaultValue.EMPTY_OBJECT)).positions,r=e.colors,t=S.defaultValue(e.colorsPerVertex,!1);if(!S.defined(o)||o.length<2)throw new c.DeveloperError("At least two positions are required.");if(S.defined(r)&&(t&&r.length<o.length||!t&&r.length<o.length-1))throw new c.DeveloperError("colors has an invalid length.");this._positions=o,this._colors=r,this._colorsPerVertex=t,this._arcType=S.defaultValue(e.arcType,F.ArcType.GEODESIC),this._granularity=S.defaultValue(e.granularity,I.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=S.defaultValue(e.ellipsoid,R.Ellipsoid.WGS84),this._workerName="createSimplePolylineGeometry";var a=1+o.length*R.Cartesian3.packedLength;a+=S.defined(r)?1+r.length*W.Color.packedLength:1,this.packedLength=a+R.Ellipsoid.packedLength+3}f.pack=function(e,o,r){if(!S.defined(e))throw new c.DeveloperError("value is required");if(!S.defined(o))throw new c.DeveloperError("array is required");var t;r=S.defaultValue(r,0);var a=e._positions,i=a.length;for(o[r++]=i,t=0;t<i;++t,r+=R.Cartesian3.packedLength)R.Cartesian3.pack(a[t],o,r);var l=e._colors;for(i=S.defined(l)?l.length:0,o[r++]=i,t=0;t<i;++t,r+=W.Color.packedLength)W.Color.pack(l[t],o,r);return R.Ellipsoid.pack(e._ellipsoid,o,r),r+=R.Ellipsoid.packedLength,o[r++]=e._colorsPerVertex?1:0,o[r++]=e._arcType,o[r]=e._granularity,o},f.unpack=function(e,o,r){if(!S.defined(e))throw new c.DeveloperError("array is required");var t;o=S.defaultValue(o,0);var a=e[o++],i=new Array(a);for(t=0;t<a;++t,o+=R.Cartesian3.packedLength)i[t]=R.Cartesian3.unpack(e,o);var l=0<(a=e[o++])?new Array(a):void 0;for(t=0;t<a;++t,o+=W.Color.packedLength)l[t]=W.Color.unpack(e,o);var n=R.Ellipsoid.unpack(e,o);o+=R.Ellipsoid.packedLength;var s=1===e[o++],d=e[o++],p=e[o];return S.defined(r)?(r._positions=i,r._colors=l,r._ellipsoid=n,r._colorsPerVertex=s,r._arcType=d,r._granularity=p,r):new f({positions:i,colors:l,ellipsoid:n,colorsPerVertex:s,arcType:d,granularity:p})};var z=new Array(2),J=new Array(2),j={positions:z,height:J,ellipsoid:void 0,minDistance:void 0,granularity:void 0};return f.createGeometry=function(e){var o,r,t,a,i,l=e._positions,n=e._colors,s=e._colorsPerVertex,d=e._arcType,p=e._granularity,c=e._ellipsoid,f=I.CesiumMath.chordLength(p,c.maximumRadius),y=S.defined(n)&&!s,u=l.length,h=0;if(d===F.ArcType.GEODESIC||d===F.ArcType.RHUMB){var C,g,T;T=d===F.ArcType.GEODESIC?(C=I.CesiumMath.chordLength(p,c.maximumRadius),g=H.PolylinePipeline.numberOfPoints,H.PolylinePipeline.generateArc):(C=p,g=H.PolylinePipeline.numberOfPointsRhumbLine,H.PolylinePipeline.generateRhumbArc);var v=H.PolylinePipeline.extractHeights(l,c),m=j;if(d===F.ArcType.GEODESIC?m.minDistance=f:m.granularity=p,m.ellipsoid=c,y){var E=0;for(o=0;o<u-1;o++)E+=g(l[o],l[o+1],C)+1;r=new Float64Array(3*E),a=new Uint8Array(4*E),m.positions=z,m.height=J;var b=0;for(o=0;o<u-1;++o){z[0]=l[o],z[1]=l[o+1],J[0]=v[o],J[1]=v[o+1];var P=T(m);if(S.defined(n)){var _=P.length/3;i=n[o];for(var A=0;A<_;++A)a[b++]=W.Color.floatToByte(i.red),a[b++]=W.Color.floatToByte(i.green),a[b++]=W.Color.floatToByte(i.blue),a[b++]=W.Color.floatToByte(i.alpha)}r.set(P,h),h+=P.length}}else if(m.positions=l,m.height=v,r=new Float64Array(T(m)),S.defined(n)){for(a=new Uint8Array(r.length/3*4),o=0;o<u-1;++o){h=Y(l[o],l[o+1],n[o],n[o+1],f,a,h)}var B=n[u-1];a[h++]=W.Color.floatToByte(B.red),a[h++]=W.Color.floatToByte(B.green),a[h++]=W.Color.floatToByte(B.blue),a[h++]=W.Color.floatToByte(B.alpha)}}else{t=y?2*u-2:u,r=new Float64Array(3*t),a=S.defined(n)?new Uint8Array(4*t):void 0;var w=0,k=0;for(o=0;o<u;++o){var D=l[o];if(y&&0<o&&(R.Cartesian3.pack(D,r,w),w+=3,i=n[o-1],a[k++]=W.Color.floatToByte(i.red),a[k++]=W.Color.floatToByte(i.green),a[k++]=W.Color.floatToByte(i.blue),a[k++]=W.Color.floatToByte(i.alpha)),y&&o===u-1)break;R.Cartesian3.pack(D,r,w),w+=3,S.defined(n)&&(i=n[o],a[k++]=W.Color.floatToByte(i.red),a[k++]=W.Color.floatToByte(i.green),a[k++]=W.Color.floatToByte(i.blue),a[k++]=W.Color.floatToByte(i.alpha))}}var G=new q.GeometryAttributes;G.position=new U.GeometryAttribute({componentDatatype:M.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:r}),S.defined(n)&&(G.color=new U.GeometryAttribute({componentDatatype:M.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:a,normalize:!0}));var L=2*((t=r.length/3)-1),V=N.IndexDatatype.createTypedArray(t,L),x=0;for(o=0;o<t-1;++o)V[x++]=o,V[x++]=o+1;return new U.Geometry({attributes:G,indices:V,primitiveType:U.PrimitiveType.LINES,boundingSphere:O.BoundingSphere.fromPoints(l)})},function(e,o){return S.defined(o)&&(e=f.unpack(e,o)),e._ellipsoid=R.Ellipsoid.clone(e._ellipsoid),f.createGeometry(e)}});
